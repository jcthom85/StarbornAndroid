# ui/transition_manager.py
from __future__ import annotations

from kivy.uix.floatlayout import FloatLayout
from kivy.uix.widget       import Widget
from kivy.uix.image        import Image
from kivy.uix.label        import Label
from kivy.graphics         import (Color, Rectangle, Line,
                                   PushMatrix, PopMatrix, Rotate, ClearColor, ClearBuffers, Fbo)
from kivy.animation        import Animation
from kivy.core.window      import Window
from kivy.app              import App
from kivy.clock            import Clock
from kivy.metrics          import dp, sp
from kivy.core.image       import Image as CoreImage
import math
from kivy.graphics.texture import Texture
import numpy as np
from ui.background_snapshot import snapshot
from kivy.uix.stencilview import StencilView

# ---------------------------------------------------------------------------
# Desaturate Function
# ---------------------------------------------------------------------------
def desaturate_texture(texture: Texture, amount: float = 1.0) -> Texture:
    w, h = texture.size
    pixels = texture.pixels

    arr = np.frombuffer(pixels, dtype=np.uint8).reshape((h, w, 4)).astype(np.float32)
    original_color = arr[:, :, :3].copy()
    grayscale = (arr[:, :, 0] * 0.21 + arr[:, :, 1] * 0.72 + arr[:, :, 2] * 0.07)
    blended_color = original_color * (1 - amount) + np.stack([grayscale]*3, axis=-1) * amount
    arr[:, :, :3] = blended_color

    new_pixels = arr.astype(np.uint8).tobytes()
    new_tex = Texture.create(size=(w, h), colorfmt='rgba')
    new_tex.blit_buffer(new_pixels, colorfmt='rgba', bufferfmt='ubyte')
    new_tex.flip_vertical()
    return new_tex

# ---------------------------------------------------------------------------
# Assets for the system-menu transition
# ---------------------------------------------------------------------------
VIGNETTES = {
    "shop"     : ("images/ui/shop_vignette.png",     "images/ui/shop_icon.png",     0.2),
    "cooking"  : ("images/ui/cooking_vignette.png",  "images/ui/cooking_icon.png",  0.2),
    "tinkering": ("images/ui/tinkering_vignette.png","images/ui/tinkering_icon.png",0.2),
    "fishing"  : ("images/ui/fishing_vignette.png",  "images/ui/fishing_icon.png",  0.2),
    "combat"   : ("images/ui/combat_vignette.png", None,                          0.0),
}

# ---------------------------------------------------------------------------
# Tunables for vignette/icon scale & final opacity
# ---------------------------------------------------------------------------
VIGNETTE_SCALE              = 1.5
ICON_PX                     = dp(480)
ICON_FINAL_ALPHA            = 0.2
BLUR_FACTOR                 = 16
COMBAT_BLUR_FACTOR          = 4     # Blur for combat screen (1 = no blur)
COMBAT_DESATURATION_LEVEL   = 0.35

# ---------------------------------------------------------------------------
# TransitionManager
# ---------------------------------------------------------------------------
class TransitionManager:
    def __init__(self):
        self.overlay           : FloatLayout | None = None
        self.is_transitioning  : bool = False
        self._restore_ops      : list[tuple[Widget, float]] = []
        self._sharp = None
        self._blur = None
        self._vignette = None
        self._icon = None

    def slide_transition(self, direction: str, move_cb: callable, duration=0.4):
        if self.is_transitioning:
            return

        self.is_transitioning = True
        app = App.get_running_app()
        game = app.current_game
        scatter = app._scatter
        
        # Widgets to animate
        bg = game.environment_loader
        title = game.ids.title_label
        details_scroll = game.ids.details_scroll
        underline = game.ids.get('title_underline')

        # --- Create snapshots of the old room's elements ---
        old_bg_tex = snapshot(bg, downsample=1)
        old_title_tex = snapshot(title, downsample=1)
        old_details_tex = snapshot(details_scroll, downsample=1)
        old_underline_tex = snapshot(underline, downsample=1) if underline else None

        old_bg_tex.flip_vertical()
        old_title_tex.flip_vertical()
        old_details_tex.flip_vertical()

        old_bg_pos = bg.to_window(*bg.pos)
        old_title_pos = title.to_window(*title.pos)
        old_details_pos = details_scroll.to_window(*details_scroll.pos)
        old_underline_pos = underline.to_window(*underline.pos) if underline else (0, 0)

        old_bg_size = (bg.size[0] * scatter.scale, bg.size[1] * scatter.scale)
        old_title_size = (title.size[0] * scatter.scale, title.size[1] * scatter.scale)
        old_details_size = (details_scroll.size[0] * scatter.scale, details_scroll.size[1] * scatter.scale)
        old_underline_size = (underline.size[0] * scatter.scale, underline.size[1] * scatter.scale) if underline else (0, 0)

        old_bg_img = Image(texture=old_bg_tex, size=old_bg_size, pos=old_bg_pos,
                           allow_stretch=True, keep_ratio=False)
        old_title_img = Image(texture=old_title_tex, size=old_title_size, pos=old_title_pos,
                              allow_stretch=True, keep_ratio=False)
        old_details_img = Image(texture=old_details_tex, size=old_details_size, pos=old_details_pos,
                                allow_stretch=True, keep_ratio=False)
        old_underline_img = None
        if underline and old_underline_tex:
            old_underline_img = Image(texture=old_underline_tex, size=old_underline_size, pos=old_underline_pos,
                                      allow_stretch=True, keep_ratio=False)

        # --- Hide original widgets ---
        bg.opacity = 0
        title.opacity = 0
        details_scroll.opacity = 0
        if underline:
            underline.opacity = 0

        # --- Setup overlay ---
        self.overlay = FloatLayout(size=Window.size, pos=(0, 0), opacity=0)
        stencil = StencilView(size=Window.size, pos=(0, 0))
        self.overlay.add_widget(stencil)
        
        stencil.add_widget(old_bg_img)
        stencil.add_widget(old_title_img)
        if old_underline_img:
            stencil.add_widget(old_underline_img)
        stencil.add_widget(old_details_img)
        
        Window.add_widget(self.overlay)
        # Reveal overlay on next frame so layout/texture sizes settle first
        Clock.schedule_once(lambda *_: setattr(self.overlay, 'opacity', 1), 0)

        # --- Animate old room out ---
        if direction == 'east': # swipe left
            anim_bg = Animation(x=old_bg_img.x - Window.width, duration=duration, t='out_cubic')
            anim_title = Animation(x=old_title_img.x - Window.width, duration=duration, t='out_cubic')
            anim_details = Animation(x=old_details_img.x - Window.width, duration=duration, t='out_cubic')
            anim_underline = Animation(x=(old_underline_img.x - Window.width) if old_underline_img else 0, duration=duration, t='out_cubic') if old_underline_img else None
        elif direction == 'west': # swipe right
            anim_bg = Animation(x=old_bg_img.x + Window.width, duration=duration, t='out_cubic')
            anim_title = Animation(x=old_title_img.x + Window.width, duration=duration, t='out_cubic')
            anim_details = Animation(x=old_details_img.x + Window.width, duration=duration, t='out_cubic')
            anim_underline = Animation(x=(old_underline_img.x + Window.width) if old_underline_img else 0, duration=duration, t='out_cubic') if old_underline_img else None
        elif direction == 'north': # swipe down
            anim_bg = Animation(y=old_bg_img.y - Window.height, duration=duration, t='out_cubic')
            anim_title = Animation(y=old_title_img.y - Window.height, duration=duration, t='out_cubic')
            anim_details = Animation(y=old_details_img.y - Window.height, duration=duration, t='out_cubic')
            anim_underline = Animation(y=(old_underline_img.y - Window.height) if old_underline_img else 0, duration=duration, t='out_cubic') if old_underline_img else None
        else: # south (swipe up)
            anim_bg = Animation(y=old_bg_img.y + Window.height, duration=duration, t='out_cubic')
            anim_title = Animation(y=old_title_img.y + Window.height, duration=duration, t='out_cubic')
            anim_details = Animation(y=old_details_img.y + Window.height, duration=duration, t='out_cubic')
            anim_underline = Animation(y=(old_underline_img.y + Window.height) if old_underline_img else 0, duration=duration, t='out_cubic') if old_underline_img else None
        
        anim_bg.start(old_bg_img)
        Clock.schedule_once(lambda dt: anim_title.start(old_title_img), 0.05)
        Clock.schedule_once(lambda dt: anim_details.start(old_details_img), 0.05)
        if old_underline_img and anim_underline:
            Clock.schedule_once(lambda dt: anim_underline.start(old_underline_img), 0.05)

        # --- Move to new room and prepare it ---
        def setup_new_room(*_):
            if move_cb:
                move_cb()

            # --- Create snapshots of the new room's elements ---
            new_bg_tex = snapshot(bg, downsample=1)

            new_bg_tex.flip_vertical()

            new_bg_size = (bg.size[0] * scatter.scale, bg.size[1] * scatter.scale)

            new_bg_img = Image(texture=new_bg_tex, size=new_bg_size,
                               allow_stretch=True, keep_ratio=False)

            # Position new images off-screen
            if direction == 'east':
                new_bg_img.pos = (Window.width, old_bg_pos[1])
            elif direction == 'west':
                new_bg_img.pos = (-Window.width, old_bg_pos[1])
            elif direction == 'north':
                new_bg_img.pos = (old_bg_pos[0], Window.height)
            else: # south
                new_bg_img.pos = (old_bg_pos[0], -Window.height)
            
            stencil.add_widget(new_bg_img)

            # --- Animate new room in ---
            if direction in ('east', 'west'):
                new_anim_bg = Animation(x=old_bg_pos[0], duration=duration, t='out_cubic')
            else:
                new_anim_bg = Animation(y=old_bg_pos[1], duration=duration, t='out_cubic')

            def on_new_in_complete(*_):
                # Remove overlay first so the real UI is visible
                if self.overlay and self.overlay.parent:
                    Window.remove_widget(self.overlay)
                self.overlay = None

                # Fade in the live UI: title, underline, and description
                try:
                    # Ensure starting from 0 in case layout code toggled visibility
                    title.opacity = 0
                    if underline:
                        underline.opacity = 0
                    details_scroll.opacity = 0

                    Animation(opacity=1, duration=0.18).start(title)
                    if underline:
                        Animation(opacity=1, duration=0.18).start(underline)
                    Animation(opacity=1, duration=0.18).start(details_scroll)
                except Exception:
                    pass

                # Restore original widgets' visibility and end transition
                bg.opacity = 1
                def _end(*_):
                    self.is_transitioning = False
                Clock.schedule_once(_end, 0.2)

            new_anim_bg.bind(on_complete=on_new_in_complete)
            new_anim_bg.start(new_bg_img)

        anim_bg.bind(on_complete=setup_new_room)

    # ------------------------------------------------------------------ #
    # Combined combat entry transition
    # ------------------------------------------------------------------ #
    def play_combined_combat_entry(self, switch_screen_callback, duration=1.8):
        if self.is_transitioning:
            return

        self.is_transitioning = True
        app = App.get_running_app()
        game = app.current_game

        # --- Stage 1: Snapshot and prepare the final blurred background ---
        background_widget = game.environment_loader
        sharp_tex = snapshot(background_widget)

        blur_tex = self._make_blur_from_texture(sharp_tex, COMBAT_BLUR_FACTOR)
        blur_tex = desaturate_texture(blur_tex, COMBAT_DESATURATION_LEVEL)

        v_assets = VIGNETTES.get("combat")
        v_src, _, vignette_alpha = v_assets

        composed_tex = self._compose_system_bg(
            blur_tex=blur_tex,
            vignette_source=v_src,
            icon_source=None,
            vignette_size=(Window.width * VIGNETTE_SCALE, Window.height * VIGNETTE_SCALE),
            vignette_center=(Window.width * 0.5, Window.height * 0.5),
            vignette_alpha=vignette_alpha,
            icon_size=(0,0), icon_center=(0,0), icon_alpha=0
        )

        # --- Stage 2: Setup for the character rush animation ---
        self.overlay = FloatLayout(size=Window.size, pos=(0, 0))
        # REMOVED: final_bg is no longer needed in the overlay. The BattleScreen will handle its own fade-in.

        speed_lines_bg = Widget(size=Window.size, pos=(0, 0), opacity=0)
        with speed_lines_bg.canvas:
            Color(1, 1, 1, 0.6)
            cx, cy = Window.center
            for i in range(40):
                ang = math.radians(i * 9)
                ex  = cx + math.cos(ang) * Window.width
                ey  = cy + math.sin(ang) * Window.height
                Line(points=[cx, cy, ex, ey], width=1.1)

        black_bg = Widget(size=Window.size, pos=(0, 0), opacity=0)
        with black_bg.canvas:
            Color(0, 0, 0, 1)
            Rectangle(size=black_bg.size, pos=black_bg.pos)

        sprite_size = dp(384)
        rush_sprite = Image(source='images/characters/nova_combat.png',
                            size_hint=(None, None), size=(sprite_size, sprite_size),
                            pos=(-sprite_size, Window.height * 0.3))
        
        slash_effect = Widget(size_hint=(None, None),
                              size=(0, Window.height * 1.5),
                              pos=(Window.width * 0.5, Window.height * -0.25),
                              opacity=0)
        with slash_effect.canvas:
            Color(1, 1, 1, 0.9)
            PushMatrix()
            self.slash_rotate = Rotate(angle=25, origin=slash_effect.center)
            Rectangle(size=slash_effect.size, pos=slash_effect.pos)
            PopMatrix()
        slash_effect.bind(pos=lambda i,p: setattr(self.slash_rotate, 'origin', i.center))

        # ADDED: Create and configure the "Prepare for battle!" text label.
        battle_text = Label(
            text="[b]Prepare for battle![/b]",
            markup=True,
            font_name='Orbitron-Black',
            font_size=sp(36),
            color=(1, 0.9, 0.5, 1),
            outline_color=(0, 0, 0),
            outline_width=2,
            size_hint=(None, None),
            opacity=0
        )
        with battle_text.canvas.before:
            PushMatrix()
            self.text_rotate = Rotate(angle=-8, origin=battle_text.center)
        with battle_text.canvas.after:
            PopMatrix()
        battle_text.bind(center=lambda inst, _: setattr(self.text_rotate, 'origin', inst.center))

        battle_text.texture_update()
        battle_text.size = battle_text.texture_size
        battle_text.pos  = (Window.width, Window.height * 0.72)

        self.overlay.add_widget(speed_lines_bg)
        self.overlay.add_widget(black_bg)
        self.overlay.add_widget(slash_effect)
        self.overlay.add_widget(rush_sprite)
        self.overlay.add_widget(battle_text) # ADDED: Add the text to the overlay.
        Window.add_widget(self.overlay)

        # --- Stage 3: Animation timeline ---
        p1, p2, p3 = duration * .3, duration * .4, duration * .3

        anim_lines_in  = Animation(opacity=1, duration=p1 * .5)
        anim_dash_in   = Animation(center_x=Window.width * .5, duration=p1, t='out_cubic')
        anim_fade_in_black = Animation(opacity=1, duration=p2)
        anim_slash     = (Animation(opacity=1, width=dp(100), duration=p2 * .2, t='out_circ') +
                          Animation(opacity=0, duration=p2 * .4, t='in_quad'))
        # MODIFIED: Character now slides off screen instead of just fading.
        anim_exit_rush = Animation(center_x=-sprite_size, opacity=0, duration=p3, t='in_cubic')
        
        # ADDED: Animation for the battle text to slide into view.
        anim_text_in   = Animation(center_x=Window.width * .5, opacity=1,
                                   duration=p2 * .5, t='out_back')

        # --- Stage 4: Animation callbacks ---
        def _midpoint(*_):
            if switch_screen_callback:
                switch_screen_callback(composed_tex)
            
            # MODIFIED: Start the exit animations for all rush elements.
            anim_exit_rush.start(rush_sprite)
            anim_exit_rush.start(battle_text) # Text now slides out with the sprite.
            Animation(opacity=0, duration=p3).start(speed_lines_bg)
            Animation(opacity=0, duration=p3).start(black_bg)

        def _on_exit(*_):
            # This now runs after the rush elements have animated off-screen.
            if self.overlay and self.overlay.parent:
                Window.remove_widget(self.overlay)
            self.overlay = None
            self.is_transitioning = False

        anim_fade_in_black.bind(on_complete=_midpoint)
        # MODIFIED: The exit callback is now bound to the completion of the main sprite's exit animation.
        anim_exit_rush.bind(on_complete=_on_exit)

        # --- Stage 5: Start the sequence ---
        if hasattr(game, 'audio') and hasattr(game.audio, 'play_sfx'):
            game.audio.play_sfx('slash_transition')

        anim_lines_in.start(speed_lines_bg)
        anim_dash_in.start(rush_sprite)
        anim_fade_in_black.start(black_bg)
        Clock.schedule_once(lambda _: anim_slash.start(slash_effect), p1 * 0.7)
        # ADDED: Schedule the text animation to start.
        Clock.schedule_once(lambda _: anim_text_in.start(battle_text), p1)

    # ------------------------------------------------------------------ #
    # Exploration â†’ System overlay
    # ------------------------------------------------------------------ #
    def launch_system(self,
                      system_key: str,
                      switch_callback: callable,
                      blur_time: float = 1.0,
                      fade_time: float = 0.3):
        if self.is_transitioning:
            return
        self.is_transitioning = True

        app      = App.get_running_app()
        game     = app.current_game
        background_widget = game.environment_loader

        self._restore_ops.clear()
        remaining = 0

        def _one_done(anim, widget):
            nonlocal remaining
            remaining -= 1
            if remaining == 0:
                _after_fade()

        def _fade_widget(w):
            nonlocal remaining
            if w is None or not hasattr(w, "opacity"):
                return
            self._restore_ops.append((w, float(getattr(w, "opacity", 1.0))))
            anim = Animation(opacity=0.0, d=fade_time, t="out_quad")
            anim.bind(on_complete=_one_done)
            remaining += 1
            anim.start(w)

        for w in list(game.ids.viewport.children):
            if w is background_widget:
                continue
            _fade_widget(w)

        if remaining == 0:
            _after_fade()

        def _after_fade():
            sharp_tex = snapshot(background_widget)

            # FIX: Restore the flip, but ONLY for non-combat systems.
            if system_key != "combat":
                try:
                    sharp_tex.flip_vertical()
                except Exception:
                    pass

            sharp_tex.min_filter = 'linear'
            sharp_tex.mag_filter = 'linear'

            blur_amount = COMBAT_BLUR_FACTOR if system_key == "combat" else BLUR_FACTOR
            blur_tex  = self._make_blur_from_texture(sharp_tex, blur_amount)
            
            if system_key == "combat":
                blur_tex = desaturate_texture(blur_tex, COMBAT_DESATURATION_LEVEL)

            self.overlay = FloatLayout(size=Window.size, pos=(0, 0))

            sharp = Image(texture=sharp_tex, allow_stretch=True, keep_ratio=False,
                          size=self.overlay.size, pos=self.overlay.pos, opacity=1.0)
            blur  = Image(texture=blur_tex,  allow_stretch=True, keep_ratio=False,
                          size=self.overlay.size, pos=self.overlay.pos, opacity=0.0)

            v_assets = VIGNETTES.get(system_key)
            v_src, i_src, vignette_alpha = v_assets

            vw, vh = self.overlay.size
            v_w, v_h = vw * VIGNETTE_SCALE, vh * VIGNETTE_SCALE
            vignette = Image(
                source=v_src,
                allow_stretch=True, keep_ratio=False,
                size_hint=(None, None),
                size=(v_w, v_h),
                pos_hint={'center_x': 0.5, 'center_y': 0.5},
                opacity=0.0
            )
            icon = None
            if i_src:
                icon = Image(
                    source=i_src,
                    size_hint=(None, None),
                    size=(ICON_PX, ICON_PX),
                    pos_hint={'center_x': .5, 'center_y': .5},
                    opacity=0.0
                )

            self.overlay.add_widget(sharp)
            self.overlay.add_widget(blur)
            self.overlay.add_widget(vignette)
            if icon:
                self.overlay.add_widget(icon)
            Window.add_widget(self.overlay)

            self._sharp = sharp
            self._blur = blur
            self._vignette = vignette
            self._icon = icon if icon else None

            anim_sharp    = Animation(opacity=0.0, d=blur_time, t="out_quad")
            anim_blur     = Animation(opacity=1.0, d=blur_time, t="out_quad")
            anim_vignette = Animation(opacity=vignette_alpha, d=blur_time, t="out_quad")
            anim_icon     = Animation(opacity=ICON_FINAL_ALPHA,     d=blur_time, t="out_quad")

            anim_sharp.start(sharp)
            anim_blur.start(blur)
            anim_vignette.start(vignette)
            if icon:
                anim_icon.start(icon)

            composed_tex = self._compose_system_bg(
                blur_tex=blur_tex,
                vignette_source=v_src,
                icon_source=i_src if i_src else None,
                vignette_size=(v_w, v_h),
                vignette_center=(Window.width * 0.5, Window.height * 0.5),
                vignette_alpha=vignette_alpha,
                icon_size=(ICON_PX, ICON_PX),
                icon_center=(Window.width * 0.5, Window.height * 0.5),
                icon_alpha=ICON_FINAL_ALPHA if i_src else 0.0
            )

            app.last_room_tex = composed_tex

            def _after_blur_complete(*_):
                if switch_callback:
                    switch_callback()
                self.is_transitioning = False

            anim_blur.bind(on_complete=_after_blur_complete)

    def _make_blur_from_texture(self, sharp_tex, factor: int):
        w, h = Window.size
        dw = max(1, int(w / max(1, factor)))
        dh = max(1, int(h / max(1, factor)))

        fbo = Fbo(size=(dw, dh), with_stencilbuffer=False)
        with fbo:
            ClearColor(0, 0, 0, 0)
            ClearBuffers()
            Color(1, 1, 1, 1)
            Rectangle(texture=sharp_tex, size=(dw, dh), pos=(0, 0))
        fbo.draw()

        tex = fbo.texture
        tex.min_filter = 'linear'
        tex.mag_filter = 'linear'
        return tex

    def _compose_system_bg(self,
                           blur_tex,
                           vignette_source: str,
                           icon_source: str,
                           vignette_size: tuple[float, float],
                           vignette_center: tuple[float, float],
                           vignette_alpha: float,
                           icon_size: tuple[float, float],
                           icon_center: tuple[float, float],
                           icon_alpha: float):
        vignette_tex = CoreImage(vignette_source).texture if vignette_source else None
        icon_tex     = CoreImage(icon_source).texture if icon_source else None

        fbo = Fbo(size=Window.size, with_stencilbuffer=True)

        vw, vh = Window.size
        v_w, v_h = vignette_size
        v_cx, v_cy = vignette_center
        v_x, v_y = v_cx - v_w / 2.0, v_cy - v_h / 2.0

        i_w, i_h = icon_size
        i_cx, i_cy = icon_center
        i_x, i_y = i_cx - i_w / 2.0, i_cy - i_h / 2.0

        with fbo:
            ClearColor(0, 0, 0, 0)
            ClearBuffers()
            Color(1, 1, 1, 1)
            Rectangle(texture=blur_tex, size=(vw, vh), pos=(0, 0))
            if vignette_tex:
                Color(1, 1, 1, vignette_alpha)
                Rectangle(texture=vignette_tex, size=(v_w, v_h), pos=(v_x, v_y))
            if icon_tex:
                Color(1, 1, 1, icon_alpha)
                Rectangle(texture=icon_tex, size=(i_w, i_h), pos=(i_x, i_y))

        fbo.draw()
        return fbo.texture

    def close(self):
        Clock.schedule_once(lambda *_: self._do_close(), 0)

    def _do_close(self):
        if self.is_transitioning:
            return
        self.is_transitioning = True

        app = App.get_running_app()
        game = getattr(app, "current_game", None) if app else None

        if not game:
            try:
                if self.overlay and self.overlay.parent:
                    Window.remove_widget(self.overlay)
            except Exception:
                pass
        else:
            game.input_locked = True

        dur = 1.0

        try:
            system_key = "combat" # Assuming close is from a system screen
            v_assets = VIGNETTES.get(system_key)
            _, _, vignette_alpha = v_assets

            if self._vignette is not None:
                self._vignette.opacity = vignette_alpha
            if self._icon is not None:
                self._icon.opacity = ICON_FINAL_ALPHA
        except Exception:
            pass

        anim_targets: list[tuple[Animation, Widget]] = []

        if self._restore_ops:
            for w, old in list(self._restore_ops):
                if not w or not hasattr(w, "opacity"):
                    continue
                try:
                    w.opacity = 0.0
                except Exception:
                    continue
                anim_targets.append((Animation(opacity=old, d=dur, t="out_quad"), w))

        if self._vignette is not None and getattr(self._vignette, "parent", None):
            anim_targets.append((Animation(opacity=0.0, d=dur, t="out_quad"), self._vignette))
        if self._icon is not None and getattr(self._icon, "parent", None):
            anim_targets.append((Animation(opacity=0.0, d=dur, t="out_quad"), self._icon))
        if self._blur is not None and getattr(self._blur, "parent", None):
            try:
                Animation(opacity=0.0, d=dur, t="out_quad").start(self._blur)
            except Exception:
                pass
        if self._sharp is not None:
            try:
                self._sharp.opacity = 0.0
            except Exception:
                pass

        if not anim_targets:
            try:
                if self.overlay and self.overlay.parent:
                    Window.remove_widget(self.overlay)
            except Exception:
                pass
            self.overlay = None
            self._sharp = self._blur = self._vignette = self._icon = None
            self._restore_ops = []
            if game:
                game.input_locked = False
            self.is_transitioning = False
            return

        remaining = {"n": len(anim_targets)}

        def _one_finished(*_):
            remaining["n"] -= 1
            if remaining["n"] <= 0:
                try:
                    if self.overlay and self.overlay.parent:
                        Window.remove_widget(self.overlay)
                except Exception:
                    pass
                self.overlay = None
                self._sharp = self._blur = self._vignette = self._icon = None
                self._restore_ops = []
                if game:
                    game.input_locked = False
                self.is_transitioning = False

        for anim, widget in anim_targets:
            anim.bind(on_complete=_one_finished)
            try:
                anim.start(widget)
            except Exception:
                _one_finished()

    def play_iris_wipe_close(self, switch_screen_callback, duration=0.6):
        if self.is_transitioning:
            return

        self.is_transitioning = True
        app = App.get_running_app()
        game = app.current_game

        self.overlay = FloatLayout(size=Window.size, pos=(0, 0))
        bars = {
            'top':    Widget(size_hint=(1, 0.5), pos_hint={'top': 1.5}),
            'bottom': Widget(size_hint=(1, 0.5), pos_hint={'y': -0.5}),
            'left':   Widget(size_hint=(0.5, 1), pos_hint={'x': -0.5}),
            'right':  Widget(size_hint=(0.5, 1), pos_hint={'right': 1.5})
        }
        for bar in bars.values():
            with bar.canvas:
                Color(0, 0, 0, 1)
                Rectangle(size=bar.size, pos=bar.pos)
            bar.bind(size=lambda i, s: i.canvas.children[-1].size == s,
                     pos=lambda i, p: i.canvas.children[-1].pos  == p)
            self.overlay.add_widget(bar)

        anim = (Animation(pos_hint={'top':   1}, duration=duration, t='in_out_cubic') &
                Animation(pos_hint={'y':     0}, duration=duration, t='in_out_cubic') &
                Animation(pos_hint={'x':     0}, duration=duration, t='in_out_cubic') &
                Animation(pos_hint={'right': 1}, duration=duration, t='in_out_cubic'))

        def on_wipe_complete(*_):
            if switch_screen_callback:
                switch_screen_callback()
            Window.remove_widget(self.overlay)
            self.overlay          = None
            self.is_transitioning = False

        anim.bind(on_complete=on_wipe_complete)

        Window.add_widget(self.overlay)
        if hasattr(game, 'audio') and hasattr(game.audio, 'play_sfx'):
            game.audio.play_sfx('iris_wipe_close')

        anim.start(bars['top'])
        anim.start(bars['bottom'])
        anim.start(bars['left'])
        anim.start(bars['right'])
